---
title: 杂七杂八--JS
time: 2017.01.13
layout: post
tags:
- JS
- 笔记
excerpt: 本文主要记录了JS高程里关于对象和函数的部分。
---

变量：基本类型（undefined,NULL,number,string,Boolean）和引用类型(object)。

基本类型的值传递：将变量的值复制一份，然后把这个值赋给新变量所在的位置。

引用类型的值传递：将对象在内存中的地址赋给新变量，是引用传递，2个变量会指向内存中的同一个对象。

函数的参数传递：是值传递。如果是向参数传递基本类型的值，会把这个值传递给函数的局部变量（包含`arguments`对象）。如果传递引用类型的值，会把这个对象在堆中的地址传给函数的局部变量。

作用域链：前端是当前执行代码所在的环境的变量对象，比如函数的就是包含arguments对象的变量。下一个变量来自包含环境，然后依次。在一个环境中可以访问到某个变量，就是因为在作用域链中可以访问到这个变量。

执行环境：全局和局部（函数）2种类型。

延长作用域链的方法：`try-catch`语句的`catch`块；`with`语句。
{% highlight js %}
	with (expression) {   //将expression加到作用域链的前端
	  statement
	}
	try         //用来测试代码中的错误
	{
	   //在此运行代码
	}
	catch(err)
	{
	   //在此处理错误
	}
{% endhighlight %}

没有块作用域。

如果在函数内部，初始化变量的时候没有用`var`，则该变量会被添加到全局环境中。

垃圾回收：标记清楚，引用计数。

####Object
#####Array
    toString()：将数组转成以逗号隔开的字符串。或者用join(',')方法更好。
    Array.isArray(value)：确定某个值是不是数组。
    push()：把值推入数组末尾，返回数组的长度。
    pop()：移除数组最后一项，返回移除的项。
    shift()：移除数组中的第一项，返回移除的项。
    unshift()：把值推入数组前面，返回数组长度。
    reverse()：反转数组，返回排序后的数组。
    sort()：默认是升序，先将数组的每一项转成字符串再排序。接收一个函数。返回排序后的数组。
    concat()：基于当前数组中的所有项创建一个新数组。复制原数组的副本，返回新数组。
    slice()：接收1或2个参数，即返回项的起始和结束位置，不会影响原数组。
    splice()：接收3个参数。第一个是要删除（或替换）的项的位置，第二个是修改几项的数字（如果是增加就传0），第三个是要替换的内容。如果参数为空，会返回一个空数组。
    indexOf()：接收2个参数，第一个是要查找的项，第二个是查找的起始位置的索引。返回要查找的项在数组中的位置，如果没有返回-1。
    lastIndexOf()：接收2个参数，不过它是从后往前找，第一个是要查找的项，第二个是查找的起始位置的索引。返回要查找的项在数组中的位置，如果没有返回-1。
    every()：对数组中每一项运行给定函数，如果每项返回true，则返回true。不修改数组中的值。
    some()：对数组中每一项运行给定函数，如果有一项返回true，则返回true。不修改数组中的值。
    forEach()：对数组中的每一项运行给定函数，没有返回值。不修改数组中的值。
    map()：对数组中的每一项运行给定函数，返回每次的结果组成的数组。不修改数组中的值。
    filter()：对数组中的每一项运行给定函数，返回结果为true的项组成的数组。不修改数组中的值。
    reduce()：函数有4个参数，prev（前一个值）,cur（当前值）,index（索引）,array（数组对象），函数的返回值会作为下一项的第一个值。
    reduceRight()：从后向前。
#####Date对象
    new Date()：接收日期字符串、毫秒数，返回日期对象。也可以传和Date.UTC()一样的参数。
    Date.prase()：接收日期字符串，返回毫秒数。
    Date.UTC(2005，0，1，22，20，40)：返回毫秒数。
#####RegExp
#####Function
    函数是Function类型的实例，函数名是指向函数对象的指针。
    函数声明和函数表达式的区别：解析器会率先读取函数声明，并使其在执行任何代码之前可以访问到。函数表达式必须等到解析器执行到它所在的代码行，才会被解释执行。
    arguments对象：保存函数参数，它有一个callee属性，是一个指针，指向拥有这个arguments对象的函数。caller属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为NULL。length属性是函数的参数个数。prototype属性。
    this对象：引用的是函数据以执行的环境对象。
    call()/apply()：在特定的作用域中调用函数，设置函数体内this对象的值。apply()的2个参数：一个是在其中运行函数的作用域（设置this的值是什么），一个是参数数组（或arguments对象）。call的2个参数：一个是在其中运行函数的作用域（设置this的值是什么），一个是参数（必须一个个列举出来）。
    bind()：与call()/apply()类似，但是会创建一个函数的实例，函数的this值会被绑定到bind里面的参数。
#####String对象
    charAt()：返回给定位置的字符。
    charCodeAt()：返回给定位置的字符的字符编码。
    concat()：将一个或多个字符串拼接起来，返回新字符串。
    slice()/substr()/substring()：第一个参数都是开始位置，slice()和substring()的第二个参数是结束位置，substr()的第二个参数是要返回的字符个数。如果没有第二个参数，将字符串长度作为结束位置。参数为负数时，slice()将参数都加上字符串长度，substr()将第一个加上字符串长度，第二个为0，substring()将参数都转为0。返回新字符串，不会改变原字符串。
    indexOf()：接收2个参数，第一个是要查找的字符串 ，第二个是查找的起始位置的索引。返回要查找的项在字符串中的位置，如果没有返回-1。
    lastIndexOf()：接收2个参数，不过它是从后往前找，第一个是要查找的项，第二个是查找的起始位置的索引。返回要查找的项在字符串中的位置，如果没有返回-1。
    trim()：创建字符串的副本，删除前后的所有空格，返回结果。
    toLowerCase()/toLocaleLowerCase()/toUpperCase()/toLocaleUpperCase()：小写/小写/大写/大写。
    split()：分割字符串，第一个参数是分隔符，第二个参数是指定数组大小。
#####Global对象
    eval()：只接受一个字符串，要执行的ECMAScript字符串。
#####Math对象
    min()/max()
    Math.ceil()：向上舍入
    Math.floor()：向下舍入
    Math.round()：标准舍入
    Math.random()
    
####创建对象
* 工厂模式
* 构造函数模式：函数名以大写字母开头，必须用new操作符。new出来的实例有`constructor`属性，指向构造函数的原型对象。
* 原型模式：让所有的对象实例共享原型对象的属性和方法。每个函数都有`prototype`属性，指向通过调用构造函数而创建的那个对象实例的原型对象。
	* `Person.prototype`指向原型对象，`Person.prototype.constructor`指向Person。
	* 创建的实例person1,person2的`prototype`（内部属性，不能直接访问到）都指向`Person.prototype`，所以这个实例其实与构造函数没有直接关系，只是与构造函数的原型属性有关。	
	* 如果在实例中添加了一个与原型同名的属性，则会覆盖与原型同名的属性，但是不会修改原型上的那个属性。先在实例上找该属性，没有找到再到原型中去找。
	* `hasOwnProperty()：person1.hasOwnProperty("name")`，属性存在于实例中，返回true。
	in："name" in person1，无论属性是在对象中还是原型中，只要能访问到就返回true。
	hasPrototypeProperty()：hasPrototypeProperty(person1，"name")：在原型中访问到返回true，要是被重写了在实例中访问到，就返回false。
	注意：如果是用对象字面量的形式来写`Person.prototype`，一定要在里面加上`constructor:Person`。因为对象字面量写相当于是重写了`prototype`,会覆盖掉它原有的一些属性。
	* 对原型所做的任何修改都能立即从实例中反映出来，即使是在创建了实例再修改原型。实例中的指针指向原型，而不是构造函数。
	* 如果是通过一个实例来修改原型的某个属性，那么在其他实例上也能得到修改后的属性，这是使用原型模式的缺点。
* 构造函数模式+原型模式
* 动态原型模式
* 寄生构造函数模式
* 稳妥构造函数模式：没有公共属性，也不使用this，适合在一些安全环境和防止数据被改动的环境中使用。

####原型链
	实现方法：让原型对象等于另一个类型的实例。
	在通过原型链实现继承的情况下，一直沿着原型链向上搜索属性。
	确定原型链和实例的关系：方法1，instanceof(instance instanceof Object)，只要是在原型链中出现过的构造函数都会返回true；方法2，isPrototypeOf(Object.prototype.isPrototypeOf(instance))，只要是原型链中出现过的原型都会返回true。
	注意：在通过原型链实现继承时，不能再用对象字面量的方法创建原型，因为这样会重写原型链。
	等同于SubType.prototype.colors = ["red","blue","green"];
* 借用构造函数：在子类构造函数内部调用超类型构造函数，用`call()`和`apply()`。
* 组合继承：原型链+借用构造函数。
* 原型式继承：借助已有对象创建新对象。
`Object()`：接收2个参数，一个是用作新对象原型的对象，一个是为新对象定义额外属性的对象。
* 寄生式继承
* 寄生组合式继承：2次调用超类型继承函数，一次是创建子类型的原型时，一次是在子类型构造函数内部。

####函数
函数声明提升：执行代码前会先读取函数声明。

闭包：有权限访问另一个函数作用域中的变量的函数。

匿名函数的执行环境具有全局性，其this对象通常指向window。

让匿名函数取得其包含作用域的this对象。

解决内存泄漏的方法：将闭包变量手动置为null，解除对其的引用。

立即执行函数：立即执行里面的代码，执行完后将里面的变量销毁。

{% highlight js %}
	(function(){
		//这里是块级作用域
	})()
{% endhighlight %}

私有变量：在函数中定义的变量。
